function extractObjectFromArray(e,r){for(var n={},t=0;t<e.length;t++){var i=e[t],a=r(i);assertValidPublicKey(a);var o=PREFIX+a;invariant(!(o in n),"OrderedMap: IDs returned by the key extraction function must be unique."),n[o]=i}return n}function OrderedMapImpl(e,r){this._normalizedObj=e,this._computedPositions=null,this.length=r}function assertValidPublicKey(e){invariant(""!==e&&("string"==typeof e||"number"==typeof e),"OrderedMap: Key must be non-empty, non-null string or number.")}function assertValidRangeIndices(e,r,n){invariant("number"==typeof e&&"number"==typeof r&&r>=0&&e>=0&&n>=e+r,"OrderedMap: `mapRange` and `forEachRange` expect non-negative start and length arguments within the bounds of the instance.")}function _fromNormalizedObjects(e,r){invariant(e&&e.constructor===Object&&(!r||r.constructor===Object),"OrderedMap: Corrupted instance of OrderedMap detected.");var n,t={},i=0;for(n in e)e.hasOwnProperty(n)&&(t[n]=e[n],i++);for(n in r)r.hasOwnProperty(n)&&(n in t||i++,t[n]=r[n]);return new OrderedMapImpl(t,i)}var assign=require("Object.assign"),invariant=require("invariant"),PREFIX="key:",OrderedMapMethods={has:function(e){assertValidPublicKey(e);var r=PREFIX+e;return r in this._normalizedObj},get:function(e){assertValidPublicKey(e);var r=PREFIX+e;return this.has(e)?this._normalizedObj[r]:void 0},merge:function(e){return invariant(e instanceof OrderedMapImpl,"OrderedMap.merge(...): Expected an OrderedMap instance."),_fromNormalizedObjects(this._normalizedObj,e._normalizedObj)},map:function(e,r){return this.mapRange(e,0,this.length,r)},mapRange:function(e,r,n,t){var i=this._normalizedObj,a={},o=0;assertValidRangeIndices(r,n,this.length);var s=r+n-1;for(var d in i)if(i.hasOwnProperty(d)){if(o>=r){if(o>s)break;var u=i[d];a[d]=e.call(t,u,d.substr(PREFIX.length),o)}o++}return new OrderedMapImpl(a,n)},filter:function(e,r){return this.filterRange(e,0,this.length,r)},filterRange:function(e,r,n,t){var i={},a=0;return this.forEachRange(function(r,n,o){if(e.call(t,r,n,o)){var s=PREFIX+n;i[s]=r,a++}},r,n),new OrderedMapImpl(i,a)},forEach:function(e,r){this.forEachRange(e,0,this.length,r)},forEachRange:function(e,r,n,t){assertValidRangeIndices(r,n,this.length);var i=this._normalizedObj,a=0,o=r+n-1;for(var s in i)if(i.hasOwnProperty(s)){if(a>=r){if(a>o)break;var d=i[s];e.call(t,d,s.substr(PREFIX.length),a)}a++}},mapKeyRange:function(e,r,n,t){var i=this.indexOfKey(r),a=this.indexOfKey(n);return invariant(void 0!==i&&void 0!==a,"mapKeyRange must be given keys that are present."),invariant(a>=i,"OrderedMap.mapKeyRange(...): `endKey` must not come before `startIndex`."),this.mapRange(e,i,a-i+1,t)},forEachKeyRange:function(e,r,n,t){var i=this.indexOfKey(r),a=this.indexOfKey(n);invariant(void 0!==i&&void 0!==a,"forEachKeyRange must be given keys that are present."),invariant(a>=i,"OrderedMap.forEachKeyRange(...): `endKey` must not come before `startIndex`."),this.forEachRange(e,i,a-i+1,t)},keyAtIndex:function(e){var r=this._getOrComputePositions(),n=r.keyByIndex[e];return n?n.substr(PREFIX.length):void 0},keyAfter:function(e){return this.nthKeyAfter(e,1)},keyBefore:function(e){return this.nthKeyBefore(e,1)},nthKeyAfter:function(e,r){var n=this.indexOfKey(e);return invariant(void 0!==n,"OrderedMap.nthKeyAfter: The key `%s` does not exist in this instance.",e),this.keyAtIndex(n+r)},nthKeyBefore:function(e,r){return this.nthKeyAfter(e,-r)},indexOfKey:function(e){assertValidPublicKey(e);var r=PREFIX+e,n=this._getOrComputePositions(),t=n.indexByKey[r];return void 0===t?void 0:t},toArray:function(){var e=[],r=this._normalizedObj;for(var n in r)r.hasOwnProperty(n)&&e.push(r[n]);return e},_getOrComputePositions:function(){var e=this._computedPositions;return e||this._computePositions(),this._computedPositions},_computePositions:function(){this._computedPositions={keyByIndex:{},indexByKey:{}};var e=this._computedPositions.keyByIndex,r=this._computedPositions.indexByKey,n=0,t=this._normalizedObj;for(var i in t)t.hasOwnProperty(i)&&(e[n]=i,r[i]=n,n++)}};assign(OrderedMapImpl.prototype,OrderedMapMethods);var OrderedMap={from:function(e){return invariant(e instanceof OrderedMapImpl,"OrderedMap.from(...): Expected an OrderedMap instance."),_fromNormalizedObjects(e._normalizedObj,null)},fromArray:function(e,r){return invariant(Array.isArray(e),"OrderedMap.fromArray(...): First argument must be an array."),invariant("function"==typeof r,"OrderedMap.fromArray(...): Second argument must be a function used to determine the unique key for each entry."),new OrderedMapImpl(extractObjectFromArray(e,r),e.length)}};module.exports=OrderedMap;
//# sourceMappingURL=OrderedMap.js.map